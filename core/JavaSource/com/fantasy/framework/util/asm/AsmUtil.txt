package com.fantasy.framework.util.asm;

import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.List;

import org.objectweb.asm.Attribute;
import org.objectweb.asm.ByteVector;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.util.TraceClassVisitor;

import com.fantasy.framework.util.FantasyClassLoader;
import com.fantasy.framework.util.common.PathUtil;
import com.fantasy.framework.util.common.StringUtil;
import com.fantasy.framework.util.common.file.FileUtil;
import com.fantasy.framework.util.regexp.RegexpUtil;
import com.fantasy.security.bean.User;
import com.fantasy.security.bean.UserGroup;

public class AsmUtil implements Opcodes {

	static class CommentAttribute extends Attribute {

		private String comment;

		public CommentAttribute(final String comment) {
			super("Comment");
			this.comment = comment;
		}

		@Override
		public boolean isUnknown() {
			return false;
		}

		@Override
		protected Attribute read(final ClassReader cr, final int off, final int len, final char[] buf, final int codeOff, final Label[] labels) {
			return new CommentAttribute(cr.readUTF8(off, buf));
		}

		@Override
		protected ByteVector write(final ClassWriter cw, final byte[] code, final int len, final int maxStack, final int maxLocals) {
			return new ByteVector().putShort(cw.newUTF8(comment));
		}

	}

	public static Class<?> makeClass(String className, Field[] fields) {
		String relativePath = RegexpUtil.replace(className, "\\.", "/");
		ClassWriter cw = new ClassWriter(Opcodes.ASM4);
		
		TraceClassVisitor cv = new TraceClassVisitor(cw, new PrintWriter(System.out));  
		
		cv.visit(V1_1, ACC_PUBLIC, relativePath, null, "java/lang/Object", null);

		// 构造方法
		MethodVisitor mv = cv.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
		mv.visitVarInsn(ALOAD, 0);
		mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
		mv.visitInsn(RETURN);
		mv.visitMaxs(1, 1);
		mv.visitEnd();

		for (int i = 0; i < fields.length; i++) {
			String fieldName = fields[i].getFieldName();
			String signature = fields[i].getSignature();
			String setMd = "set" + StringUtil.upperCaseFirst(fieldName);
			String getMd = "get" + StringUtil.upperCaseFirst(fieldName);

			String typeof = Type.getType(fields[i].getFieldType()).getDescriptor();
			
			String getof = Type.getMethodDescriptor(Type.getType(fields[i].getFieldType()));
			String setof = Type.getMethodDescriptor(Type.getReturnType("V"), Type.getType(fields[i].getFieldType()));
			
			int[] loadAndReturnOf = loadAndReturnOf(typeof);

			if(fieldName == "groups"){
				System.out.println(getof);
				System.out.println(setof);
			}
			
			// 属性
			cv.visitField(ACC_PRIVATE, fieldName, typeof, signature, null).visitEnd();

			System.out.println(getMd + ">" + (signature != null ? ("()" + signature) : null));
			// get方法
			mv = cv.visitMethod(ACC_PUBLIC, getMd, getof, signature != null ? ("()" + signature) : null, null);
			mv.visitCode();
			mv.visitVarInsn(ALOAD, 0);
			mv.visitFieldInsn(GETFIELD, className, fieldName, typeof);
			mv.visitInsn(loadAndReturnOf[1]);
			mv.visitMaxs(2, 1);
			mv.visitEnd();

			// set方法
			mv = cv.visitMethod(ACC_PUBLIC, setMd, setof, signature != null ? ("(" + signature + ")V") : null, new String[] {});
			mv.visitCode();
			mv.visitVarInsn(ALOAD, F_FULL);
			mv.visitVarInsn(25, 1);//loadAndReturnOf[0]
//			mv.visitLocalVariable("this", getFieldType(className), getFieldType(className), new Label(), new Label(), 0);
//			mv.visitLocalVariable(fieldName, setof, signature != null ? ("(" + signature + ")V") : null, new Label(), new Label(), 1);
			mv.visitFieldInsn(PUTFIELD, relativePath, fieldName, typeof);
			mv.visitInsn(RETURN);
			mv.visitMaxs(2, 2);
			mv.visitEnd();

		}

		// toString方法
		mv = cv.visitMethod(1, "toString", "()".concat(getFieldType(String.class)), null, null);
		mv.visitCode();
		mv.visitLdcInsn(" AsmUtil makeClass !");
		mv.visitInsn(176);
		mv.visitMaxs(1, 1);
		mv.visitEnd();
		cv.visitEnd();

		cv.visitEnd();
		byte[] code = cw.toByteArray();

		String classPath = PathUtil.getClasses() + relativePath + ".class";

		FileUtil.writeFile(code, classPath);
		try {
			return FantasyClassLoader.getClassLoader().loadClass(PathUtil.getClasses(), className);
		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		}
	}

	private static String setof(String typeof) {
		return "(" + typeof + ")V";
	}

	private static String getof(String typeof) {
		return "()" + typeof;
	}

	private static int[] loadAndReturnOf(String typeof) {
		if (typeof.equals("I") || typeof.equals("Z")) {
			return new int[] { ILOAD, IRETURN };
		} else if (typeof.equals("J")) {
			return new int[] { LLOAD, LRETURN };
		} else if (typeof.equals("D")) {
			return new int[] { DLOAD, DRETURN };
		} else if (typeof.equals("F")) {
			return new int[] { FLOAD, FRETURN };
		} else {
			return new int[] { ALOAD, ARETURN };
		}
	}

	protected static String getFieldType(Class<?> clazz) {
		return "L" + RegexpUtil.replace(clazz.getName(), "\\.", "/") + ";";
	}

	protected static String getFieldType(String classname) {
		return "L" + RegexpUtil.replace(classname, "\\.", "/") + ";";
	}

	public static String getSignature(Class<?> clazz, Class<?>[] genericTypes) {
		if (List.class.isAssignableFrom(clazz) && genericTypes.length != 0) {
			return "L" + RegexpUtil.replace(clazz.getName(), "\\.", "/") + "<L" + RegexpUtil.replace(genericTypes[0].getName(), "\\.", "/") + ";>;";
		}
		return null;
	}

	/**
	 * 
	 * <p>
	 * 比较参数类型是否一致
	 * </p>
	 * 
	 * @param types
	 *            asm的类型({@link Type})
	 * @param clazzes
	 *            java 类型({@link Class})
	 * @return
	 */
	private static boolean sameType(Type[] types, Class<?>[] clazzes) {
		// 个数不同
		if (types.length != clazzes.length) {
			return false;
		}

		for (int i = 0; i < types.length; i++) {
			if (!Type.getType(clazzes[i]).equals(types[i])) {
				return false;
			}
		}
		return true;
	}

	/**
	 * 
	 * <p>
	 * 获取方法的参数名
	 * </p>
	 * 
	 * @param m
	 * @return
	 */
	public static String[] getMethodParamNames(final Method m) {
		final String[] paramNames = new String[m.getParameterTypes().length];
		final String n = m.getDeclaringClass().getName();
		ClassReader cr = null;
		try {
			cr = new ClassReader(n);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		cr.accept(new ClassVisitor(Opcodes.ASM4) {
			public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {
				final Type[] args = Type.getArgumentTypes(desc);
				// 方法名相同并且参数个数相同
				if (!name.equals(m.getName()) || !sameType(args, m.getParameterTypes())) {
					return super.visitMethod(access, name, desc, signature, exceptions);
				}
				if (signature != null) {
					System.out.println(desc + "|" + signature + "|");
				}
				MethodVisitor v = super.visitMethod(access, name, desc, signature, exceptions);
				return new MethodVisitor(Opcodes.ASM4, v) {

					public void visitLocalVariable(String name, String desc, String signature, Label start, Label end, int index) {
						int i = index - 1;
						// 如果是静态方法，则第一就是参数
						// 如果不是静态方法，则第一个是"this"，然后才是方法的参数
						if (Modifier.isStatic(m.getModifiers())) {
							i = index;
						}
						if (i >= 0 && i < paramNames.length) {
							paramNames[i] = name;
						}
					}
				};
			}
		}, 0);
		return paramNames;
	}

	public static void main(String[] args) throws SecurityException, NoSuchMethodException {
		String classname = "com.fantasy.framework.util.asm.WorkLoadObject";
		
//		ClassWriter cw = new ClassWriter(0);  
//        
//        cv.visit(Opcodes.V1_5, Opcodes.ACC_PUBLIC + Opcodes.ACC_ABSTRACT + Opcodes.ACC_INTERFACE,  
//        		classname, null, "java/lang/Object",  
//                 new String[] { "java/lang/Object" });  
//        cv.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, "LESS", "I", null, new Integer(-1)).visitEnd();  
//        cv.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, "EQUAL", "I", null, new Integer(0)).visitEnd();  
//        cv.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, "GREATER", "I", null, new Integer(1)).visitEnd();  
//        cv.visitMethod(Opcodes.ACC_PUBLIC + Opcodes.ACC_ABSTRACT, "compareTo", "(Ljava/lang/Object;)I", null, null).visitEnd();  
//        cv.visitEnd();  
		
		
		Class clazz = User.class;// 
		// for (Method m : clazz.getDeclaredMethods()) {// //
		// // System.out.println(m.toGenericString());
		// // try {
		// // System.out.println(m.getName() + ">" + Arrays.toString(JavassistUtil.getParamNames(classname, m)));
		// // } catch (NotFoundException e) {
		// // e.printStackTrace();
		// // } catch (MissingLVException e) {
		// // e.printStackTrace();
		// // }
		// if ("getUserGroups".equals(m.getName()) || "setUserGroups".equals(m.getName()))
		// System.out.println(m.getName() + ">" + Arrays.toString(getMethodParamNames(m)));
		// }
		// System.out.println("------------------");
		clazz = makeClass(classname, new Field[] { new Field("name", String.class), new Field("adds", String.class), new Field("groups", List.class, new Class[] { UserGroup.class }) });
		for (Method m : clazz.getDeclaredMethods()) {
			if ("getGroups".equals(m.getName()) || "setGroups".equals(m.getName()))
				System.out.println(m.getName() + ">" + Arrays.toString(getMethodParamNames(m)));
		}
		// String[] s = getMethodParamNames(Classes.class.getMethod("getMethodParamNames", Method.class));
		// System.out.println(Arrays.toString(s));
		//
		// s = getMethodParamNames(Classes.class.getDeclaredMethod("sameType", Type[].class, Class[].class));
		// System.out.println(Arrays.toString(s));
		//
		// s = getMethodParamNames(MethodVisitor.class.getDeclaredMethod("visitAnnotation", String.class, Boolean.TYPE));
		// System.out.println(Arrays.toString(s));

		// 对String，Object，thread等jdk自带类型不起作用
	}

}



/*TODO 添加自动转换类型的拦截器
                if (!String.class.isAssignableFrom(property.getType())) {
                    methodInfos.add(new MethodInfo("set" + StringUtil.upperCaseFirst(property.getName()), Type.getMethodDescriptor(Type.getReturnType("V"), new Type[]{Type.getType(String.class)}), null, new MethodCreator() {

                        @Override
                        public void execute(MethodVisitor mv) {
                            String className = AsmContext.getContext().get("className", String.class);
                            String newClassInternalName = className.replace('.', '/');

                            String fieldName = property.getName();
                            String descriptor = Type.getDescriptor(String.class);
                            int[] loadAndReturnOf = AsmUtil.loadAndReturnOf(descriptor);

                            Label l0 = new Label();
                            Label l1 = new Label();
                            Label l2 = new Label();

                            mv.visitLabel(l0);
                            mv.visitVarInsn(Opcodes.ALOAD, Opcodes.F_FULL);
                            mv.visitVarInsn(loadAndReturnOf[0], Opcodes.F_APPEND);
                            mv.visitFieldInsn(Opcodes.PUTFIELD, newClassInternalName, fieldName, descriptor);
                            mv.visitLabel(l1);
                            mv.visitInsn(Opcodes.RETURN);
                            mv.visitLabel(l2);
//                            mv.visitLocalVariable("this", AsmUtil.getTypeDescriptor(className), null, l0, l2, 0);
//                            mv.visitLocalVariable(fieldName, descriptor, AsmUtil.getSignature(String.class, new Class<?>[0]), l0, l2, 1);
                            mv.visitVarInsn(loadAndReturnOf[0], Opcodes.F_APPEND); //ALOAD
                            mv.visitMaxs(2, 2);
                        }

                    }));
                }
                */